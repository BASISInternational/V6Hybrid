0010 REM ------------------------------------------
0020 REM --- lister: List a data file's content ---
0030 REM ------------------------------------------
0040 REM 
0050 REM  Copyright 2002-2004, AddonSoftware
0060 REM 
0070 REM  This program is free software; you can redistribute it and/or modify
0080 REM  it under the terms of the GNU General Public License as published by
0090 REM  the Free Software Foundation; either version 2 of the License, or
0100 REM  (at your option) any later version.
0110 REM 
0120 REM  This program is distributed in the hope that it will be useful,
0130 REM  but WITHOUT ANY WARRANTY; without even the implied warranty of
0140 REM  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
0150 REM  GNU General Public License (http://www.gnu.org/licenses/gpl.html) 
0160 REM  for more details.
0170 REM 
0180 REM  Author:  Knute Snortum <knute@addonsoftware.com> 
0190 REM 
0200 REM  Usage:   call "lister"
0210 REM 
0220 REM  Version: 0.1
0230 REM 
0240 REM --- Inits
0250 PRINT 'PUSH','CS',"lister - List a data file's content"
0260 LET SEP$=$0A$
0270 DIM U$(79,"-")
0280 LET CHAN=UNT
0290 LET LINES=0,PAGE=21
0300 LET REC_HOLD$=""
0310 LET STYLE$="VERT",VARIABLES=1
0320 LET DIRECTION=1
0330 REM --- Get a file name
0340 GET_FILE:
0350 INPUT 'LF','SB',"Enter file name: ",'SF',F$
0360 IF F$="" THEN GOTO THE_END
0370 CLOSE (CHAN)
0380 OPEN (CHAN,ERR=GET_FILE)F$
0390 LET FID$=FID(CHAN),FIN$=FIN(CHAN),TYPE=ASC(AND($0F$,FID$(1,1))),RECSZ=DEC
0390:(FID$(7,2)),KEYSZ=DEC(FID$(2,1)),RECNUM=DEC(FID$(3,4)),KEYD=0,INDEXD=0,SO
0390:RTD=0,MKEYD=0
0400 IF TYPE=0 THEN LET INDEXD=0 ELSE IF TYPE=6 OR TYPE=7 THEN LET MKEYD=1,KEY
0400:D=1 ELSE IF TYPE=2 THEN IF RECSZ=0 THEN LET SORTD=1 ELSE LET KEYD=1
0410 IF KEYD THEN EXTRACT (CHAN,ERR=GET_FILE_NEXT0,KEY="")
0420 GET_FILE_NEXT0:
0430 IF MKEYD AND POS($00$<>FIN$(86))=0 THEN LET MKEYD=0
0440 PRINT "Full path=",FID$(9)
0450 REM --- Multiple key?
0460 MULTI_KEY:
0470 IF MKEYD=0 THEN IF CTL=4 THEN GOTO GET_FILE ELSE GOTO GET_KEY
0480 INPUT 'SB',"Enter key number: ",'SF',SRT$
0490 IF CTL=4 THEN GOTO GET_FILE
0500 READ (CHAN,KEY="",DIR=DIRECTION,KNUM=NUM(SRT$),DOM=MULTI_KEY_NEXT0)
0510 MULTI_KEY_NEXT0:
0520 REM --- Get a key 
0530 GET_KEY:
0540 LET LINES=0
0550 IF INDEXD=1 THEN GOTO GET_INDEX
0560 GET_KEY_INPUT: INPUT 'SB',"Enter key, LAST, FIRST, FIND, MOD, DEL, <CR>=n
0560:ext, <F1>=prev, <F4>=file",'LF',"<F2>=Vert/Horz, <F3>=Var/Fld --> ",'SF',
0560:X$
0570 IF CVS(X$,4)="LAST" THEN LET K$=KEYL(CHAN,END=END_OF_FILE); GOTO GET_KEY_
0570:EXTRACT
0580 IF CVS(X$,4)="FIRST" THEN LET K$=KEYF(CHAN,END=END_OF_FILE); GOTO GET_KEY
0580:_EXTRACT
0590 IF CVS(X$,4)="FIND" THEN GOTO FIND_STRING
0600 IF CVS(X$,4)="MOD" THEN GOTO MODIFY_REC
0610 IF CVS(X$,4)="DEL" THEN REMOVE (CHAN,KEY=K$); GOTO GET_KEY_DIR
0620 IF CTL=2 THEN IF STYLE$="HORZ" THEN LET STYLE$="VERT"; PRINT "Style=verti
0620:cal"; GOTO GET_KEY ELSE LET STYLE$="HORZ"; PRINT "Style=horizontal"; GOTO
0620: GET_KEY
0630 IF CTL=3 THEN IF VARIABLES=0 THEN LET VARIABLES=1; PRINT "Parse variables
0630:"; GOTO GET_KEY ELSE LET VARIABLES=0; PRINT "Field numbers"; GOTO GET_KEY
0640 IF CTL=4 THEN GOTO MULTI_KEY
0650 LET X0=POS("~"=X$); WHILE X0; LET X$=X$(1,X0-1)+CHR(NUM(X$(X0+1,3)))+X$(X
0650:0+4),X0=POS("~"=X$); WEND
0660 LET K$=X$
0670 IF SORTD THEN GOTO GET_KEY_INPUT
0680 GET_KEY_EXTRACT: IF K$<>"" AND KEYD THEN EXTRACT (CHAN,KEY=K$,DOM=GET_KEY
0680:_NEXT0,ERR=GET_KEY)
0690 GET_KEY_NEXT0:
0700 GET_KEY_DIR: IF CTL=1 THEN IF DIRECTION=1 THEN LET DIRECTION=-1; PRINT "D
0700:irection=Backward" ELSE LET DIRECTION=1; PRINT "Direction=Forward" FI; RE
0700:AD (CHAN,DIR=DIRECTION,END=END_OF_FILE); READ (CHAN,DIR=DIRECTION,END=END
0700:_OF_FILE); GOTO GET_KEY
0710 LET X0$=KEY(CHAN,END=END_OF_FILE),K$=X0$; GOSUB STRIP_NONPRINT; LET KEY$=
0710:X0$
0720 REM --- Get an index
0730 GET_INDEX:
0740 IF INDEXD=0 THEN GOTO GET_DATA_REC
0750 INPUT 'LF',"Enter index, <enter> for next, <F4> for new file: ",X$
0760 IF CTL=4 THEN GOTO GET_FILE
0770 IF X$="" THEN LET I=I+1 ELSE LET I=NUM(X$,ERR=END_OF_FILE)
0780 REM --- Get data record
0790 GET_DATA_REC:
0800 IF KEYD THEN READ RECORD(CHAN,DIR=DIRECTION,END=END_OF_FILE)A$ ELSE READ 
0800:(CHAN,DIR=DIRECTION,END=END_OF_FILE)
0810 IF INDEXD THEN READ RECORD(CHAN,IND=I)A$
0820 IF STRINGD THEN READ (CHAN,END=END_OF_FILE)A$
0830 REM --- Display record
0840 DISPLAY_DATA:
0850 IF STYLE$="VERT" THEN PRINT 'SB',"           ....+....1....+....2....+...
0850:.3....+....4....+....5....+....6....+...",'SF'; GOSUB PAUSE
0860 IF KEYD THEN PRINT 'SB',"key=(",STR(LEN(KEY$)),")",@(10),"[",'SF',KEY$,'S
0860:B',"]",'SF',; IF A$>"" AND POS(K$=A$)<>1 THEN PRINT " KEY/DATA MISMATCH! 
0860:" ELSE PRINT ""; GOSUB PAUSE
0870 IF SORTD OR A$="" THEN GOTO END_LOOP
0880 IF INDEXD THEN PRINT 'SB',"INDEX=",'SF',STR(I); GOSUB PAUSE
0890 LET FLD=1,P9=1,STR_NUM=0,NUM_NUM=0
0900 DISPLAY_DATA_NEXT_FLD: LET P=POS(SEP$=A$(P9))
0910 IF P=0 THEN LET P=LEN(A$(P9))+1
0920 LET REC$=A$(P9,P-1)
0930 GOSUB PARSE_DATES
0940 LET X0$=REC$; GOSUB STRIP_NONPRINT; LET REC$=X0$
0950 IF VARIABLES THEN GOSUB VAR_NAMES ELSE PRINT 'SB',"fld",STR(FLD), FI; IF 
0950:VARIABLES=0 OR IS_STR THEN PRINT "(",STR(P-1),")",'SF',
0960 IF STYLE$="HORZ" THEN PRINT 'SB',"[",'SF',REC$,'SB',"]",'SF',; GOTO DISPL
0960:AY_DATA_DATE
0970 DISPLAY_DATA_TOO_LONG: IF LEN(REC$)>68 THEN LET REC_HOLD$=REC$(69),REC$=R
0970:EC$(1,68)
0980 PRINT @(10),'SB',"[",'SF',REC$,; REM GOSUB PAUSE
0990 IF REC_HOLD$>"" THEN PRINT ""; GOSUB PAUSE; LET REC$=REC_HOLD$,REC_HOLD$=
0990:""; GOTO DISPLAY_DATA_TOO_LONG ELSE PRINT 'SB',"]"; GOSUB PAUSE
1000 DISPLAY_DATA_DATE: IF DATES$>"" THEN IF STYLE$="VERT" THEN PRINT @(10),'S
1000:B',"DATES: ",'SF',DATES$; GOSUB PAUSE ELSE PRINT 'SB',"->DATES: ",'SF',DA
1000:TES$,
1010 IF P=LEN(A$(P9))+1 OR POS($00$<>A$(P9+P))=0 THEN GOTO END_LOOP
1020 LET P9=P9+P,FLD=FLD+1
1030 GOTO DISPLAY_DATA_NEXT_FLD
1040 REM --- End of loop
1050 END_LOOP:
1060 IF STYLE$="VERT" THEN PRINT 'SB',U$,'SF' ELSE PRINT ""
1070 IF KEYD OR INDEXD THEN GOTO GET_KEY
1080 INPUT 'SB',"<Enter> to continue, <F4> for new file: ",'SF',*
1090 IF CTL=4 THEN GOTO GET_FILE
1100 GOTO GET_DATA_REC
1110 REM --- End of file
1120 END_OF_FILE:
1130 PRINT 'LF',"End of file",'LF'
1140 IF KEYD THEN IF DIRECTION=1 THEN LET K$=KEYF(CHAN,END=GET_KEY) ELSE LET K
1140:$=KEYL(CHAN,END=GET_KEY) FI; READ (CHAN,END=GET_KEY)
1150 GOTO GET_KEY
1160 REM --- Find a record by searching for a string
1170 FIND_STRING:
1180 PRINT 'LF','SB',"Find a record by searching for a string"
1190 FIND_STRING_INPUT0: INPUT 'SB','LF',"Enter field number: ",'SF',FLD
1200 ON CTL GOTO FIND_STRING_NEXT0,FIND_STRING_INPUT0,GET_KEY,FIND_STRING_INPU
1200:T0,GET_KEY,FIND_STRING_INPUT0
1210 FIND_STRING_NEXT0:
1220 FIND_STRING_INPUT1: INPUT 'SB',"Substring or entire field? (S,A): ",'SF',
1220:X$
1230 ON CTL GOTO FIND_STRING_NEXT1,FIND_STRING_INPUT1,FIND_STRING_INPUT0,FIND_
1230:STRING_INPUT1,GET_KEY,FIND_STRING_INPUT1
1240 FIND_STRING_NEXT1:
1250 IF POS(X$="SA")=0 THEN GOTO FIND_STRING_INPUT1
1260 IF X$="A" THEN LET BEG=1,LENGTH=999999; GOTO FIND_STRING_INPUT4
1270 FIND_STRING_INPUT2: INPUT 'SB',"Starting position: ",'SF',BEG
1280 ON CTL GOTO FIND_STRING_NEXT2,FIND_STRING_INPUT2,FIND_STRING_INPUT1,FIND_
1280:STRING_INPUT2,GET_KEY,FIND_STRING_INPUT2
1290 FIND_STRING_NEXT2:
1300 FIND_STRING_INPUT3: INPUT 'SB',"Length: ",'SF',LENGTH
1310 ON CTL GOTO FIND_STRING_NEXT3,FIND_STRING_INPUT3,FIND_STRING_INPUT2,FIND_
1310:STRING_INPUT3,GET_KEY,FIND_STRING_INPUT3
1320 FIND_STRING_NEXT3:
1330 FIND_STRING_INPUT4: INPUT 'SB',"Match string: ",'SF',MATCH$
1340 ON CTL GOTO FIND_STRING_NEXT4,FIND_STRING_INPUT4,FIND_STRING_INPUT3,FIND_
1340:STRING_INPUT4,GET_KEY,FIND_STRING_INPUT4
1350 FIND_STRING_NEXT4:
1360 IF LENGTH<>999999 AND LEN(MATCH$)<>LENGTH THEN GOTO FIND_STRING_INPUT4
1370 FIND_STRING_NEXT_KEY: LET K$=KEY(CHAN,END=END_OF_FILE)
1380 READ RECORD(CHAN,KEY=K$)A$
1390 PRINT "*",
1400 LET P9=1,F0=1
1410 FIND_STARTING_NEXT_FLD: LET L0=POS(SEP$=A$(P9))-1
1420 IF P9=0 OR L0<1 THEN GOTO FIND_STRING_NEXT_KEY
1430 LET X0$=A$(P9,L0)
1440 IF F0<FLD THEN LET F0=F0+1,P9=P9+L0+1; GOTO FIND_STARTING_NEXT_FLD
1450 IF LENGTH=999999 THEN LET LENGTH=L0
1460 IF A$(P9+BEG-1,LENGTH)<>MATCH$ THEN GOTO FIND_STRING_NEXT_KEY
1470 LET X0$=K$; GOSUB STRIP_NONPRINT; LET KEY$=X0$
1480 PRINT ""
1490 GOTO DISPLAY_DATA
1500 REM --- Modify a record
1510 REM *** THIS DOESN'T WORK WELL!!! ***
1520 MODIFY_REC:
1530 IF (INDEXD=0 AND KEYD=0) OR A$="" THEN GOTO GET_KEY
1540 PRINT 'LF','SB',"Modify a record",'LF','SF',"-->THIS WILL CHANGE YOUR DAT
1540:A<--",'LF',"*** CAUTION *** This routine does NOT change keys!",'SB'
1550 MODIFY_REC_INPUT0: INPUT 'SB','LF',"Enter field number: ",'SF',FLD
1560 ON CTL GOTO MODIFY_REC_NEXT0,MODIFY_REC_INPUT0,GET_KEY,MODIFY_REC_INPUT0,
1560:GET_KEY,MODIFY_REC_INPUT0
1570 MODIFY_REC_NEXT0:
1580 MODIFY_REC_INPUT1: INPUT 'SB',"Substring or entire field? (S,A): ",'SF',X
1580:$
1590 ON CTL GOTO MODIFY_REC_NEXT1,MODIFY_REC_INPUT1,MODIFY_REC_INPUT0,MODIFY_R
1590:EC_INPUT1,GET_KEY,MODIFY_REC_INPUT1
1600 MODIFY_REC_NEXT1:
1610 IF POS(X$="SA")=0 THEN GOTO MODIFY_REC_INPUT1
1620 IF X$="A" THEN LET BEG=1,LENGTH=999999; GOTO MODIFY_REC_INPUT4
1630 MODIFY_REC_INPUT2: INPUT 'SB',"Starting position: ",'SF',BEG
1640 ON CTL GOTO MODIFY_REC_NEXT2,MODIFY_REC_INPUT2,MODIFY_REC_INPUT1,MODIFY_R
1640:EC_INPUT2,GET_KEY,MODIFY_REC_INPUT2
1650 MODIFY_REC_NEXT2:
1660 MODIFY_REC_INPUT3: INPUT 'SB',"Length: ",'SF',LENGTH
1670 ON CTL GOTO MODIFY_REC_NEXT3,MODIFY_REC_INPUT3,MODIFY_REC_INPUT2,MODIFY_R
1670:EC_INPUT3,GET_KEY,MODIFY_REC_INPUT3
1680 MODIFY_REC_NEXT3:
1690 MODIFY_REC_INPUT4: INPUT 'SB',"Replace with: ",'SF',REPLACE$
1700 ON CTL GOTO MODIFY_REC_NEXT4,MODIFY_REC_INPUT4,MODIFY_REC_INPUT3,MODIFY_R
1700:EC_INPUT4,GET_KEY,MODIFY_REC_INPUT4
1710 MODIFY_REC_NEXT4:
1720 IF LENGTH<>999999 AND LEN(REPLACE$)<>LENGTH THEN GOTO MODIFY_REC_INPUT4
1730 MODIFY_REC_NEXT_REC: IF KEYD THEN EXTRACT RECORD(CHAN,KEY=K$)A$ ELSE EXTR
1730:ACT RECORD(CHAN,IND=I)A$
1740 LET P9=1,F0=1
1750 MODIFY_REC_NEXT_SEP: LET L0=POS(SEP$=A$(P9))-1
1760 IF P9=0 OR L0<1 THEN GOTO MODIFY_REC_NEXT_REC
1770 LET X0$=A$(P9,L0)
1780 IF F0<FLD THEN LET F0=F0+1,P9=P9+L0+1; GOTO MODIFY_REC_NEXT_SEP
1790 IF LENGTH=999999 THEN LET LENGTH=L0
1800 MODIFY_REC_INPUT5: PRINT 'LF','SB',"Is this the data to change? [",'SF',A
1800:$(P9+BEG-1,LENGTH),'SB',"] : ",'SF',; INPUT X$
1810 ON CTL GOTO MODIFY_REC_NO,MODIFY_REC_INPUT5,MODIFY_REC_INPUT4,MODIFY_REC_
1810:INPUT5,GET_KEY,MODIFY_REC_INPUT5
1820 MODIFY_REC_NO: IF X$="N" THEN GOTO MODIFY_REC_INPUT4
1830 MODIFY_REC_YES: IF X$<>"Y" THEN GOTO MODIFY_REC_INPUT5
1840 LET A$(P9+BEG-1,LENGTH)=REPLACE$
1850 IF KEYD THEN WRITE RECORD(CHAN,KEY=K$)A$ ELSE WRITE RECORD(CHAN,IND=I)A$
1860 GOTO DISPLAY_DATA
1870 REM --- Parse dates
1880 PARSE_DATES:
1890 LET DATES$="",P1=0
1900 PARSE_DATES_TRY_AGAIN: LET P2=POS(CHR(12+32)>A$(P9+P1,P-P1-1))-1
1910 IF P2<0 THEN GOTO PARSE_DATES_DONE; REM "P2=0
1920 SETERR PARSE_DATES_NEXT
1930 LET DATE$=FNB$(A$(P9+P1+P2-1,3))
1940 GOSUB VERIFY_DATES
1950 IF DATE$="" THEN LET P2=P2+1,DATE$=FNB$(A$(P9+P1+P2,3)); GOSUB VERIFY_DAT
1950:ES
1960 IF DATE$>"" THEN LET DATES$=DATES$+DATE$+" "
1970 PARSE_DATES_NEXT: LET P1=P1+P2+2; IF P1<P THEN GOTO PARSE_DATES_TRY_AGAIN
1980 PARSE_DATES_DONE: SETERR 0; RETURN
1990 REM --- Verify dates
2000 VERIFY_DATES:
2010 IF LEN(DATE$)<>8 THEN GOTO VERIFY_DATES_BAD
2020 IF DATE$(1,2)<"01" OR DATE$(1,2)>"12" THEN GOTO VERIFY_DATES_BAD
2030 IF DATE$(4,2)<"01" OR DATE$(4,2)>"31" THEN GOTO VERIFY_DATES_BAD
2040 REM IF DATE$(7,2)<"60" OR DATE$(7,2)>"99" THEN GOTO VERIFY_DATES_BAD
2050 GOTO VERIFY_DATES_DONE
2060 VERIFY_DATES_BAD: LET DATE$=""
2070 VERIFY_DATES_DONE: RETURN
2080 REM --- Print psuedo variable names"
2090 VAR_NAMES:
2100 LET IS_STR=1
2110 IF REC$="" OR POS(" "=REC$)>0 OR (P>2 AND REC$(1,1)="0") THEN GOTO VAR_NA
2110:MES_STR
2120 LET X=NUM(REC$,ERR=VAR_NAMES_STR)
2130 PRINT 'SB',"X[",STR(NUM_NUM),"]",
2140 LET NUM_NUM=NUM_NUM+1,IS_STR=0
2150 GOTO VAR_NAMES_DONE
2160 VAR_NAMES_STR: PRINT 'SB',"X",STR(STR_NUM),"$",
2170 LET STR_NUM=STR_NUM+1
2180 VAR_NAMES_DONE: RETURN
2190 REM --- Pause
2200 PAUSE:
2210 IF LINES>=PAGE THEN INPUT 'LF',@(0,22),'CL',"<enter> to continue: ",*,@(0
2210:,22),'CL',; LET LINES=0
2220 LET LINES=LINES+1
2230 RETURN
2240 REM --- String non-printable characters
2250 STRIP_NONPRINT:
2260 LET P0=POS($20$>X0$); WHILE P0; LET X0$(P0,1)="!",P0=POS($20$>X0$); WEND
2270 LET P0=POS($7E$<X0$); WHILE P0; LET X0$(P0,1)="~",P0=POS($7E$<X0$); WEND
2280 RETURN
2290 REM --- Functions (AddonSoftware only)
2300 DEF FNA$(Q$,Q2$)=STR(MOD((ASC(Q$)-32)*POS(" "<>Q2$(2,1)),100):"00")
2310 DEF FNB$(Q1$)=FNA$(Q1$(2),Q1$)+"/"+FNA$(Q1$(3),Q1$)+"/"+FNA$(Q1$(1),Q1$)
2320 REM --- This is the end
2330 THE_END:
2340 PRINT 'POP'
2350 CLOSE (CHAN)
2360 SETERR THE_BITTER_END
2370 EXIT
2380 THE_BITTER_END:
2390 RUN "SYS.AA";rem added for V17 demo project 
2400 END
